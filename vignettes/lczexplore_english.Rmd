---
title: "lczexplore_english"
author: "Matthieu Gousseff"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
resource_files:
  - vignettes/Redon.png
vignette: >
 %\VignetteIndexEntry{lczexplore_english}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
        collapse = TRUE,
        comment = "#>"
)
if (!require("png")) {
  install.packages("png")
  library("png")
}

```


# A package to explore Local Climate Zones : lczexplore
## Purpose and origin
The lczexplore package was developped thanks to the Pændora 2 project, funded by ADEME, a french agency for ecological transition.

Its purpose is to easily compare different local climate zone classifications on the same study territory.

Before using this package, one must assign a local climate zone (LCZ) type to each Spatial Reference Units of a territory.
These units can be topological units or geometries derived from pixels of a rester approach after a simple conversion.
As several workflow can produce these LCZ types, this package allows to represent them and to compare the results of these classifications (pairwise).


## Installation

Unzip the tar.gz file and install it (see `?install.packages`)

One can also install it from the github repository. This repository will be modified when the source codes will be moved to the official repository of the OrbisGis team. This temporary version can be installed for now from the author's repository : (`devtools::install_github("MGousseff/lczexplore")`).


Load the package : `library(lczexplore)`.
```

library(lczexplore)

```


# First use-case : load a file with geometries and standard LCZ


## Import files with importLCZgen function

The function `importLCZgen` is the generic import function for the file containing geometries, or Reference Spatial Units (RSU) and the associated Local Climate Zone Type (LCZ). Import of geojson and shp files was tested, but any format accepted by the function `st_read` of the `sf` package should work.

The `dirPath` and the `file` arguments set the path to the folder and the filename to be loaded. The compulsary argument  `column` is the name of the column in which are the LCZ types. The optional arguments `geomID` and `confid` allow the user to load column of geometry identifiers and a column containing a measure of the confidence associated to the LCZ type of a geometry.

The default output of `importLCZgen` is an object of class `simple feature` as defined by the openGIS consortium and as handled by the `sf` package, an R reference library for Geographical Information System vector Data [https://doi.org/10.32614/RJ-2018-009].

If one sets the argument `output="bBox"`, importLCZgen will output only the bounding box of the geometrie of the input file. It is useful, for instance, when you want to use it to crop another file and study the same area.


```{R}
dirPath<-paste0(system.file("extdata",package="lczexplore"),"/")
dirPathOSM<-paste0(dirPath,"osm/2022/Redon")
dirPathBDT<-paste0(dirPath,"bdtopo_2_2/Redon")
redonOSM<-importLCZgen(dirPath=dirPathOSM,file="rsu_lcz.geojson",column = "LCZ_PRIMARY")
redonBDT<-importLCZgen(dirPath=dirPathBDT,file="rsu_lcz.geojson",column = "LCZ_PRIMARY")
#
```
## Map the LCZ types with the function showLCZ

Once the dataset has been loaded into an R object of class `sf`, the function `showLCZ` produces the map of it's repartition. The argument`sf` sets the input dataset, the column of the LCZ types is passed to the argument `column`. The argument `wf` is just a string that will be used to produce the title of the plot, and it allows the user to specify which workflow produced the input data.

For standard LCZ types, one sets the argument `repr="standard"`, and the function will recognize levels from 1 to 10 and from 101 to 107 (the original convention). It is the recommended choice. But `standard` representation will also accept levels from 11 to 17 and from A to G.



```{R, fig.dim = c(8, 6)}
showLCZ(sf=redonOSM,wf="OSM",column="LCZ_PRIMARY",repr="standard",LCZlevels="",cols="")
```

If one regrouped some LCZ types into more general categories, or if the LCZ don't have a standard encoding, set `repr=grouped` and the pass the vector of possible levels of the variable to the argument `LCZlevels`. Pass the vector of associated colors to the argument `cols`.
If no vector of levels or no vector of colors is given, the levels will be deduced from the unique values present in the data, and the colors will be picked from the "Polychrome 36" palette of the `grDevices` package.

For instance : one can first plot the column without knowing the LCZ levels present.
```{r, fig.dim = c(8, 6)}
#showLCZ(sf=redonOSM,wf="OSM",column="LCZ_PRIMARY",repr="grouped")
showLCZ(sf=redonOSM,wf="OSM",column="LCZ_PRIMARY",repr="grouped")

```

Then, after noticing that no RSU takes the LCZ value 1, 4, 10, 103 or 106, one can simplify the plot with the following code.
Notice one has to explicitly set `drop=TRUE` to discard the unused levels.

```{R, fig.dim = c(8, 6)}
LCZlevels<-c(2, 3, 5, 6, 8, 9, 101, 102, 104, 105, 107)
showLCZ(sf=redonOSM,wf="OSM",column="LCZ_PRIMARY",repr="grouped",drop=TRUE, LCZlevels = LCZlevels)

```

The following code shows an example of color choice.

```{r, fig.dim = c(8, 6)}

LCZlevels<-c(2, 3, 5, 6, 8, 9, 101, 102, 104, 105, 107)
couleurs<-c("red","brown1","orange","coral","grey","darkgreen","chartreuse4","springgreen3",
            "darkolivegreen","black","royalblue2")
showLCZ(sf=redonOSM,wf="OSM",column="LCZ_PRIMARY",repr="grouped",drop=TRUE,LCZlevels=LCZlevels,cols=couleurs)

```

## Group several LCZ types in a category using LCZgroup2

For instance, one may want to illustrate the contour of a city, by grouping the urban LCZ and the vegetation ones. Use the `LCZgroup2` function and set the dataset with the argument `sf` and the column with `column`.Then you pass as many vectors as tehere are grouped category, each of them containing the levels to be grouped together. The newly created categories will be stored in the `outCol` column. If the user doesn't enter them, by default the column is called 'grouped'.

The newly created dataset can be mapped with `showLCZ` function.

```{r, fig.dim = c(8, 6)}
redonOSMgrouped<-LCZgroup2(redonOSM,column="LCZ_PRIMARY",
                           urban=c("1","2","3","4","5","6","7","8","9"),
                           industry="10",
                           vegetation=c("101","102","103","104"),
                           impervious="105",pervious="106",water="107",cols=c("red","black","green","grey","burlywood","blue"))
showLCZ(redonOSMgrouped, column="grouped",repr="grouped",wf="OSM",
        LCZlevels = c("urban","industry","vegetation","impervious","pervious","water"),
        cols=c("red","black","green","grey","burlywood","blue"))

```

# Compare two LCZ classification with the function compareLCZ

**The purpose of this package is to easily compare local climate zone classifications produced by different algorithms on the same study area.**
In our exmaple, the GeoClimate workflow was used with two different input data to produce two LCZ classifications : the BD TOPO® v2.2, produced by the French National Institute of Geographic and Forest Information, and OpenStreetMap.

## Maps of original data.

One has to call `compareLCZ` and feed it, for each dataset, at least the name of the sf object and the name of the colum of the LCZ. classification

*The graphical output includes 4 graphs and is easier to read after zooming or exporting.*

A map of each LCZ classification is plotted.

```{r, fig.dim = c(12,9 ), echo = FALSE}
comparaison<-compareLCZ(sf1=redonBDT,column1="LCZ_PRIMARY", wf1="BD TOPO v2.2",
                        sf2=redonOSM,column2="LCZ_PRIMARY",wf2="Open Street Map", ref=1,
                        repr="standard",exwrite=F,location="Redon",saveG="")
```


Then the geometries of both sf objects are intersected in order to get geometries where the **two classification either totally agree either totally disagree.** This agreement is plotted on a third graphics.

At last, a confusion matrix (or agreement matrix) is computed : the area of each intersected geometry and the values of the two LCZ classification are used to show how one type of the first classification is split-up between the levels of the second classification. The matrix is shown in the fourth and last graphics.


```{r, out.width = "680px"}

knitr::include_graphics(system.file('extdata/RedonCompare.png',package="lczexplore"))

```

## Output data for further analysis

`CompareLCZ `outputs a list called `matConfOut` which contains :

- `matConfOut$data` the intersected geometries, their identifiers (if `geomID` was not empty), their LCZ type and their area,
- `matConfOut$matConf` the confusion matrix,
- `matConfOut$pourcAcc` the general agreement of the two classification on the whole area (as a percentage of the global surface of the area).

At last, if `exwrite=TRUE` then `compareLCZ` outputs the data in csv file. This file can be re-imported for further analysis.

# Sensitivity of the agreement to the confidence value

Some algorithm may provide a confidence value associated to the LCZ type.
For instance, GeoClimate, for a given geometry, chooses the LCZ type according to a distance to a hypercube defining each LCZ type (in a space defined by the urban canopy parameters)?. Therefore, GeoClimate assigns the geometry to the closes type, but another type may have been quite close too. GeoClimate supplies a uniqueness value, betwwen 0 and 1. The closer it is to 1, the less the second LCZ type was a good candidate. This uniqueness can be seen as a confidence value.


## Import the necessary data : LCZ type, but also confidence.

Use the `importLCZgen` function and set the name of the geometry identifier (`geomID` argument )and the confidence value associated to the LCZ (`confid` argument).

```{r}
dirPath<-paste0(system.file("extdata",package="lczexplore"),"/")
dirPathOSM<-paste0(dirPath,"osm/2022/Redon")
dirPathBDT<-paste0(dirPath,"bdtopo_2_2/Redon")

redonOSM<-importLCZgen(dirPath=dirPathOSM,file="rsu_lcz.geojson",column = "LCZ_PRIMARY",geomID = "ID_RSU",confid="LCZ_UNIQUENESS_VALUE")

redonBDT<-importLCZgen(dirPath=dirPathBDT,file="rsu_lcz.geojson",column = "LCZ_PRIMARY",geomID = "ID_RSU",confid="LCZ_UNIQUENESS_VALUE")
```


The function `confidSensib` performs the sensitivity analysis from the output of `compareLCZ`. One can choose to export the data in a csv file and reimport them, or one can simply store the output in an r file and feed it to `confidSensib.`
```{r, fig.dim = c(8, 6)}
redonCompare<-compareLCZ(sf1=redonBDT,wf1="bdt", geomID1 = "ID_RSU",column1 ="LCZ_PRIMARY",
                         confid1 = "LCZ_UNIQUENESS_VALUE",
                         sf2=redonOSM,wf2="osm",geomID2 = "ID_RSU",column2="LCZ_PRIMARY",confid2 ="LCZ_UNIQUENESS_VALUE",exwrite=T,plot=FALSE)
```

NOTE : if the two data sets we compare have the same column names, the compareLCZ function will concatenate a ".1" string to the column names of the second file, and thes enriched names will be the ones to feed `confidSensib`.

The question we want to answer is : **Does the agreement between the two classification gets bigger if we keep only the geometries for which the LCZ value is associated to a confidence value bigger than a thershold?**

The span of the confidence values is divided on as many points as the user chooses with the argument `nPoints`

For each of these thresholds, the function only keeps the reference spatial units (RSU, i.e. the geometries) for which the confidence value is higher than the threshold. Then it computes the agreement between the classifications based on these geoms.

```{r, fig.dim = c(12,9)}
names(redonCompare$data)
confidRedon<-confidSensib(inputDf=redonCompare$data,filePath="", nPoints=10,
             wf1="bdtopo_2_2", wf2="osm",
             geomID1="ID_RSU", column1="LCZ_PRIMARY", confid1="LCZ_UNIQUENESS_VALUE",
             geomID2="ID_RSU.1",column2="LCZ_PRIMARY.1", confid2="LCZ_UNIQUENESS_VALUE.1",
             sep=";", repr="standard",
             plot=TRUE)

```

These are the main functions of the package, for further use, refer to the man page of each function.
